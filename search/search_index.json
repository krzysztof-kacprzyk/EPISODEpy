{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"api/","text":"API basis OneHotBasisFunctions compute(V, V_ranges) Compute the one-hot encoded basis functions for the given input and ranges. Parameters: V: a numpy array of shape (n_samples, n_features) V_ranges: a list of tuples or sets representing ranges of the features Returns: B: a numpy array of shape (n_samples, sum(n_unique_values)) n_unique_values_dict: a dictionary mapping feature indices to the number of unique values in each feature compute_single(V, V_ranges, feature_index) Args: V: a numpy array of shape (n_samples, n_features) V_ranges: a list of tuples or sets representing ranges of the features feature_index: index of the feature to compute the one-hot encoding for Returns: B: a numpy array of shape (n_samples, n_unique_values) composition_map CompositionMapBase Bases: ABC fit(V, T, Y, composition_scores=None) Fit the composition map model. Parameters: V ( FeatureDataset ) \u2013 The feature dataset containing the static features. T ( NpArrayOrList ) \u2013 The target values. Shape should be a list of np.ndarray or a single np.ndarray of shape (n_samples,n_timesteps). Y ( NpArrayOrList ) \u2013 The additional input features. Shape should be a list of np.ndarray or a single np.ndarray of shape (n_samples,n_timesteps). composition_scores ( ndarray , default: None ) \u2013 The composition scores. Shape should be (n_samples, n_compositions), by default None Returns: None \u2013 get_specific_feature_ranges(X_ranges, composition_index) abstractmethod Get the range of the features for a specific composition Parameters: X_ranges ( list [ tuple [ float , float ] | set [ int ]] ) \u2013 The ranges of the features for all compositions. composition_index ( int ) \u2013 The index of the composition to get the feature ranges for. Returns: list [ tuple [ float , float ] | set [ int ]] \u2013 The ranges of the features for the specified composition. predict(V) Predict the composition for the given input. Parameters: V ( FeatureDataset ) \u2013 The feature dataset containing the static features. include_indices ( bool ) \u2013 Whether to include the indices of the compositions, by default False Returns: Sequence [ Composition ] | Tuple [ Sequence [ Composition ], ndarray ] \u2013 If include_indices is False, returns a sequence of Composition objects. If include_indices is True, returns a tuple containing the sequence of Composition objects and the indices of the compositions. DecisionTreeCompositionMap Bases: CompositionMapBase __init__(composition_library, t_range, x0_index=None, train_on_whole_trajectory=True, dt_config=DecisionTreeConfig(), verbose=False, seed=0) Args: composition_library: a sequence of Composition objects dt_config: a dictionary with the configuration for the decision tree classifier categorical_features_indices: a sequence of integers representing the indices of the categorical features x0_index: an integer or float representing the index of the initial condition, or None if not included verbose: a boolean indicating whether to print the decision tree structure get_specific_feature_ranges(X_ranges, composition_index) Get the range of the features for a specific composition. Parameters: X_ranges ( list [ tuple [ float , float ] | set [ int ]] ) \u2013 The ranges of the features for all compositions. composition_index ( int ) \u2013 The index of the composition to get the feature ranges for. Returns: list [ tuple [ float , float ] | set [ int ]] \u2013 The ranges of the features for the specified composition. predict_composition_indices(V) Predict the composition indices for the given input. Parameters: V ( FeatureDataset ) \u2013 The feature dataset containing the static features. Returns: ndarray \u2013 The predicted composition indices. Shape will be (n_samples,). config ConfigBase Base class for configuration management. Provides methods to update configurations and validate keys. copy() Create a copy of the configuration instance. from_dict(config_dict) classmethod Create a ConfigBase instance from a dictionary. to_dict() Convert the configuration to a dictionary. DecisionTreeConfig __init__(max_depth=3, min_relative_gain_to_split=0.01, min_samples_leaf=10, relative_motif_cost=0.01, tune_depth=False) Initialize the configuration for the decision tree. Parameters: max_depth ( int , default: 3 ) \u2013 Maximum depth of the tree, by default 3 min_relative_gain_to_split ( float , default: 0.01 ) \u2013 Minimum relative gain to split, by default 1e-2 min_samples_leaf ( int , default: 10 ) \u2013 Minimum samples per leaf, by default 10 relative_motif_cost ( float , default: 0.01 ) \u2013 Relative cost of motif, by default 1e-2 tune_depth ( bool , default: False ) \u2013 Whether to tune the depth of the tree, by default False PropertyMapConfig Bases: ConfigBase Configuration class for PropertyMapTorch. Inherits from ConfigBase to manage configuration settings. __init__(n_epochs=1000, batch_size=256, lr=0.1, device='cpu', dis_loss_coeff_1=0.01, dis_loss_coeff_2=1e-06, last_loss_coeff=100.0, n_tune=0, dtw=False, optimizer=torch.optim.LBFGS, optimizer_params={'lr': 0.1, 'history_size': 100, 'max_iter': 20, 'line_search_fn': 'strong_wolfe'}) Initialize the configuration for PropertyMapTorch. TorchTrainerConfig Configuration class for the PyTorch trainer. Inherits from ConfigBase to manage configuration settings. __init__(composition, n_features, categorical_features_indices, cat_n_unique_dict, x0_index, t_range, n_basis_functions, property_map_config, seed) Initialize the configuration for the PyTorch trainer. copy() Create a copy of the configuration instance. cubic create_row(coordinate, order) Create a row of polynomial features for a given coordinate. Parameters: coordinate ( ndarray | Tensor ) \u2013 Coordinate for which to create the polynomial features. Should be of shape (batch_size, 2). order ( int ) \u2013 Order of the polynomial features. 0 for the function, 1 for the first derivative, and 2 for the second derivative. Returns: ndarray | Tensor \u2013 Row of polynomial features for the given coordinate and order. Shape: (batch_size, 4) Raises: ValueError \u2013 If the order is not 0, 1, or 2. evaluate_cubic(coefficients, x, derivative_order=0) Evaluate a cubic polynomial at x (or its derivatives). Parameters: coefficients : np.ndarray Coefficients of the cubic polynomial. Should be of shape (batch_size,4) The coefficients are ordered as [a,b,c,d] where the polynomial is a x^3 + b x^2 + c*x + d x : np.ndarray Input data. Should be (batch_size,n_time_points) derivative_order : int Order of derivative to evaluate. Returns: np.ndarray Value of the cubic polynomial at x. Should be (batch_size,n_time_points) first_derivative_at_end_from_cubic(coefficients, t_end) summary Parameters: coefficients ( ndarray | Tensor ) \u2013 Coefficients of the cubics of shape (batch_size, n_bounded_motifs, 4) t_end ( ndarray | Tensor ) \u2013 Time points of the final bounded transition points of shape (batch_size,) Returns: ndarray | Tensor \u2013 First derivatives at the end of the cubics of shape (batch_size,) second_derivative_at_end_from_cubic(coefficients, t_end) Calculate the second derivative at the end of the cubic. Parameters: coefficients ( ndarray | Tensor ) \u2013 Coefficients of the cubics of shape (batch_size, n_bounded_motifs, 4) t_end ( ndarray | Tensor ) \u2013 Time points of the final bounded transition points of shape (batch_size,) Returns: ndarray | Tensor \u2013 Second derivatives at the end of the cubics of shape (batch_size,) decision_tree DecisionTreeClassifier CART Decision Tree for classification with support for: - Numeric features - Categorical features - One-hot encoded labels __init__(max_depth=5, min_samples_split=2, categorical_features=None, min_gini_impurity=1e-07, metric_name='gini', offset=0.001, min_samples_leaf=1) Parameters: max_depth ( int , default: 5 ) \u2013 The maximum depth of the tree. min_samples_split ( int , default: 2 ) \u2013 The minimum number of samples required to split an internal node. categorical_features ( list of int , default: None ) \u2013 List of feature indices that are categorical. By default, None means all features are treated as numeric. continue_fit(X_new, Y_new) Incrementally fit the tree with new data (X_new, Y_new). fit(X, Y) Fit the decision tree to the data. Parameters: X ( np.ndarray of shape (n_samples, n_features) ) \u2013 Y ( np.ndarray of shape (n_samples, n_classes) ) \u2013 get_predictions_at_leaves() Get a set of all possible predictions get_updated_feature_ranges(X_ranges) Get the updated feature ranges for the new tree. predict(X) Predict class labels for each sample in X. Parameters: X ( np.ndarray of shape (n_samples, n_features) ) \u2013 Returns: np.ndarray of shape (n_samples,) \u2013 The predicted class labels (as integers). predict_proba(X) Predict class probabilities for each sample in X. Parameters: X ( np.ndarray of shape (n_samples, n_features) ) \u2013 Returns: np.ndarray of shape (n_samples, n_classes) \u2013 print_tree(node=None, depth=0) Recursively print the structure of the decision tree. Parameters: node ( TreeNode , default: None ) \u2013 The current node in the tree. If None, starts from the root. depth ( int , default: 0 ) \u2013 Current depth of the tree, used for indentation. TreeNode A simple class representing a node in the decision tree. __init__(feature_index=None, split_value=None, left=None, right=None, value=None, is_categorical=False) Parameters: feature_index ( int , default: None ) \u2013 The index of the feature used for splitting. split_value ( float or any ( threshold or category ) , default: None ) \u2013 If is_categorical=False, this is the numeric threshold. If is_categorical=True, this is the specific category. left ( TreeNode , default: None ) \u2013 Left child node. right ( TreeNode , default: None ) \u2013 Right child node. value ( ndarray , default: None ) \u2013 The class distribution (probabilities) of the leaf node. is_categorical ( bool , default: False ) \u2013 Whether the feature at feature_index is categorical. gam GAM __init__(shape_functions, bias) Args: shape_functions: a list of ShapeFunction, each shape function is a function that takes a numpy array bias: a scalar predict(X, reduce=True) Predict the value of the GAM Args: X: a numpy array of shape (batch_size, n_features) Returns: a numpy array of shape (batch_size,) prune(threshold=1e-05) Prune the shape functions whose range is smaller than the threshold ShapeFunction __call__(x) Args: x: a numpy array of shape (batch_size,) get_expected_value() Calculate the expected value of the shape function Returns: a scalar is_constant() Check if the shape function is constant Returns: a boolean maximum_value() Calculate the maximum value of the shape function Returns: a scalar minimum_value() Calculate the minimum value of the shape function Returns: a scalar range() Calculate the range of the shape function Returns: a tuple (min, max) visualize(fig=None) Creates a visualization of the shape function. It consists of two axes objects: one for the shape function and one for the histogram of the data. Returns: a figure object optimize_properties ScipyOptimizationAlgorithm Bases: OptimizationAlgorithm Optimization algorithm using SciPy's minimize function. This class allows for different optimization methods to be specified. __init__(method='L-BFGS-B') Parameters: method ( str , default: 'L-BFGS-B' ) \u2013 The optimization method to use. Defaults to 'L-BFGS-B'. calculate_score(composition, t_range, t, x, x0, optimization_alg, loss_fn, train_on_all=False, evaluate_on_all=True, train_size=0.8, seed=0) Calculate the score for the given composition and data. Parameters: composition ( Composition ) \u2013 The composition object containing motif information. t_range ( Tuple [ float , float ] ) \u2013 The time range for the evaluation. t ( ndarray ) \u2013 The time points for the evaluation. Shape (n_time_points,). x ( ndarray ) \u2013 The state variables for the evaluation. Shape (n_time_points). x0 ( Union [ float , None] ) \u2013 The initial state variable, if applicable. optimization_alg ( OptimizationAlgorithm ) \u2013 The optimization algorithm to use. loss_fn ( Callable ) \u2013 The loss function to minimize. Signature should be loss_fn(x_pred, x_true) -> float or loss_fn(x_pred, x_true) -> np.ndarray . train_on_all ( bool , default: False ) \u2013 Whether to train on all available data, by default False. evaluate_on_all ( bool , default: True ) \u2013 Whether to evaluate on all available data, by default True. train_size ( float , default: 0.8 ) \u2013 The proportion of data to use for training, by default 0.8. seed ( int , default: 0 ) \u2013 The random seed for reproducibility, by default 0. Returns: Tuple [ float , Properties ] \u2013 The loss value and the properties object containing the optimized parameters. compute_t_last_finite_transition_point(composition, t_range, arguments, t_max) Returns the last finite transition point in time based on the composition and arguments. If the composition is bounded, it returns the end of the time range. Parameters: composition ( Composition ) \u2013 The composition object containing motif information. t_range ( Tuple [ float , float ] ) \u2013 The time range for the evaluation. arguments ( dict ) \u2013 A dictionary containing the arguments, including 't_last_finite_transition_point'. t_max ( float ) \u2013 The maximum time point in the data. Returns: float \u2013 The last finite transition point in time. from_parameters_to_raw_properties(parameters, dictionary) Converts a flat array of parameters into a dictionary of arguments based on the provided mapping. Parameters: parameters ( ndarray ) \u2013 A flat array of parameters. dictionary ( dict ) \u2013 A mapping from argument names to their corresponding indices in the parameters array. key is argument name such as \"horizontal_values\", \"vertical_values\", etc. value is a tuple indicating the start and end indices in the parameters array, or None if not applicable. Returns: dict \u2013 A dictionary mapping argument names to their corresponding values. get_first_derivative_range(composition, motif_index, point1, point2, which_point) Get the range of the first derivative for a given motif and transition points. Parameters: composition ( Composition ) \u2013 The composition object containing motif information. motif_index ( int ) \u2013 Index of the motif in the composition. point1 ( ndarray ) \u2013 numpy array of shape (2,) representing the first point (time, value). point2 ( ndarray ) \u2013 numpy array of shape (2,) representing the second point (time, value). which_point ( str ) \u2013 'left' or 'right' indicating which point to consider for the derivative. Returns: Tuple [ float , float ] \u2013 The range of the first derivative at the specified point. transition_points_from_raw_properties(composition, horizontal_values, vertical_values, t_last_finite_transition_point, x0, t_range) Converts raw properties into transition points. Parameters: horizontal_values ( ndarray ) \u2013 The horizontal shifts betweet transition points. 1D array vertical_values ( ndarray ) \u2013 The vertical shifts between transition points. 1D array t_last_finite_transition_point ( float ) \u2013 The last finite transition point in time. x0 ( float ) \u2013 The initial state variable. Returns: ndarray \u2013 The calculated transition points of shape (num_transition_points, 2). property_map CubicDerivativePredictor Bases: PropertyFunction predict(V) Predict the value of the derivative based on the cubic. Parameters: V ( ndarray ) \u2013 A numpy array of shape (batch_size, n_features) containing the input features. Returns: ndarray \u2013 A numpy array containing the predicted values for the specified order. Shape is (batch_size,). GAMBasedDerivativePredictor Bases: PropertyFunction __init__(composition, gam, boundary, order, transition_point_predictors) Initialize the DerivativePredictor with a dictionary of predictors. Parameters: gam ( GAM ) \u2013 The GAM instance used for predictions. boundary ( str ) \u2013 The boundary to predict ('start' or 'end'). order ( int ) \u2013 The order of the derivative to predict (1 or 2). predict(V) Predict the value of the derivative. Parameters: V ( ndarray ) \u2013 A numpy array of shape (batch_size, n_features) containing the input features. Returns: ndarray \u2013 A numpy array containing the predicted values for the specified boundary and order. Shape is (batch_size,). GAMBasedInfiniteMotifPredictor Bases: PropertyFunction __init__(composition, gams, property_index, last_value_predictor, first_derivative_at_end_predictor) Initialize the GAMBasedInfiniteMotifPredictor. Parameters: composition ( Composition ) \u2013 predict(V) Predict the value of an infinite motif property. Parameters: V ( ndarray ) \u2013 A numpy array of shape (batch_size, n_features) containing the input features. Returns: ndarray \u2013 A numpy array containing the predicted values for the specified infinite motif property. Shape is (batch_size,). NDPropertyMap Bases: NDPropertyMapBase init_property_map(m) Initialize the 1D property map. NDPropertyMapBase Bases: ABC init_property_map(m) abstractmethod Initialize the 1D property map. PropertyFunction Bases: ABC predict(V) abstractmethod Predict the output for a given input. Parameters: X ( ndarray ) \u2013 Input data of shape (n_samples, n_features). Returns: ndarray \u2013 Predicted output of shape (n_samples,). PropertyMap Bases: PropertyMapBase PropertyMapBase Bases: ABC fit(V, T, Y, composition_map) Fit the semantic predictor to the data Parameters: V: FeatureDataset The input feature dataset. T: NpArrayOrList The target values. Y: NpArrayOrList The additional target values. predict(composition, V) Predict the properties for a given composition and input features. Parameters: composition ( Composition ) \u2013 The composition for which to predict properties. V ( FeatureDataset ) \u2013 A dataset containing the input features. Returns: Properties \u2013 An instance of Properties containing the predicted properties. SinglePropertyMap __init__(composition, transition_point_predictor, derivative_predictor, infinite_motif_predictor) Args: composition: a tuple of strings representing the composition transition_point_predictor: a dictionary with keys (transition_point_index: int,coordinate: {'x','t'}) and values of type GAM derivative_predictor: a dictionary with keys (boundary: {'start','end'},order: {1,2}) and values of type GAM infinite_motif_predictor: a list of GAM predict(V) Predict the properties for a given input. Parameters: V ( ndarray ) \u2013 A numpy array of shape (batch_size, n_features) containing the input features. Returns: Properties \u2013 An instance of Properties containing the predicted properties. TransitionPointPredictor Bases: PropertyFunction __init__(gam) Parameters: transition_point_module ( TransitionPointModule ) \u2013 The module that predicts the transition points. transition_point_index ( int ) \u2013 The index of the transition point to predict. coordinate ( str ) \u2013 The coordinate to predict ('x' or 't'). predict(V) summary Parameters: V ( ndarray ) \u2013 A numpy array of shape (batch_size, n_features) containing the input features. Returns: ndarray \u2013 A numpy array containing the predicted values for the specified transition point and coordinate. Shape is (batch_size,). semantic_predictor SemanticPredictor __init__(composition_map, property_map) Args: compostion_map: a CompositionMap object property_maps: a dictionary with keys (composition: tuple of strings) and values of type SinglePropertyMap t_range: a tuple of floats representing the range of the time variable fit(V, T, Y) Fit the semantic predictor to the data Parameters: V: FeatureDataset The input feature dataset. T: NpArrayOrList The target values. Y: NpArrayOrList The additional target values. predict(V) Predict the semantic representation Args: V: a numpy array of shape (batch_size, n_features) Returns: a list of SemanticRepresentation objects semantic_representation Composition create_composition(motifs) staticmethod Create a Composition object from a sequence of motifs. Parameters: motifs ( Tuple [ str , ...] | Sequence [ str ] ) \u2013 A sequence of motif strings. Returns: Composition \u2013 A Composition object representing the motifs. create_composition_library(list_of_motifs) staticmethod Create a library of Composition objects from a list of motifs. Parameters: list_of_motifs ( Sequence [ Tuple [ str , ...]] | Sequence [ Sequence [ str ]] ) \u2013 A sequence of sequences of motif strings. Returns: Sequence [ Composition ] \u2013 A list of Composition objects representing the motifs. Properties __init__(engine, composition, transition_points, first_derivative_start, first_derivative_end, second_derivative_end, unbounded_motif_properties=None, unbounded_motif_properties_raw=False) Initialize the Properties class. Parameters: engine ( str ) \u2013 The computational engine to use ('pytorch' or 'numpy'). composition ( Composition ) \u2013 Composition object containing motif information. transition_points ( Union [ ndarray , Tensor ] ) \u2013 Array or tensor of transition points of shape (n_samples, n_transition_points,2). first_derivative_start ( Union [ ndarray , Tensor ] ) \u2013 Array or tensor of first derivative start points of shape (n_samples, 1). first_derivative_end ( Union [ ndarray , Tensor ] ) \u2013 Array or tensor of first derivative end points of shape (n_samples, 1). second_derivative_end ( Union [ ndarray , Tensor ] ) \u2013 Array or tensor of second derivative end points of shape (n_samples, 1). unbounded_motif_properties ( Union [None, ndarray , Tensor ] , default: None ) \u2013 Properties for unbounded motifs, if applicable. Defaults to None. Raises: ValueError \u2013 If the engine is not 'pytorch' or 'numpy'. SemanticRepresentation __init__(compositions, predicted_composition_indices, engine='numpy') Initialize the SemanticRepresentation class. Parameters: compositions ( Sequence [ Composition ] ) \u2013 A sequence of Composition objects. predicted_composition_indices ( ndarray ) \u2013 An array of predicted composition indices. Should be of shape (n_samples,) and contain integers representing indices of compositions. engine ( str , default: 'numpy' ) \u2013 The computational engine to use ('pytorch' or 'numpy'), by default 'numpy' get_present_compositions() Get a list of compositions that have associated properties. Returns: Sequence [ Composition ] \u2013 A sequence of compositions with properties. get_properties_by_composition(composition) Get properties for a specific composition. Parameters: composition ( Composition ) \u2013 The composition for which to retrieve properties. Returns: Properties \u2013 The properties associated with the specified composition. torch_model DerivativeModule Bases: Module predict(features, finite_coordinates) Predict the derivatives based on the processed features and finite coordinates. Parameters: features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. finite_coordinates ( Tensor ) \u2013 Finite coordinates tensor of shape (batch_size, n_coordinates, 2). Returns: tuple \u2013 A tuple containing three tensors: the predicted first derivative at the start, the predicted first derivative at the end, and the predicted second derivative at the end. Each tensor has shape (batch_size,). predict_first_derivative_at_end(features, transition_points) Predict the first derivative at the end of the transition. Parameters: features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. transition_points ( Tensor ) \u2013 Transition points tensor of shape (batch_size, n_transition_points, 2). Returns: Tensor \u2013 Predicted first derivative at the end of the transition. Shape: (batch_size,) Raises: ValueError \u2013 If the first_derivative_at_end_status is unknown. predict_first_derivative_at_start(features, transition_points) Predict the first derivative at the start of the transition. Parameters: features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. transition_points ( Tensor ) \u2013 Transition points tensor of shape (batch_size, n_transition_points, 2). Returns: Tensor \u2013 Predicted first derivative at the start of the transition. Shape: (batch_size,) Raises: ValueError \u2013 If the first_derivative_at_start_status is unknown. predict_second_derivative_at_end(features) Predict the second derivative at the end of the transition. Parameters: features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. Returns: Tensor \u2013 Predicted second derivative at the end of the transition. Shape: (batch_size,) Raises: ValueError \u2013 If the second_derivative_at_end_status is unknown. FinalMotifPropertyModule Bases: Module predict(processed_features, transition_points, first_derivative_at_end, second_derivative_at_end) Predict the generalized additive model (GAM) for the given processed features. Parameters: processed_features ( ProcessedFeatures ) \u2013 An instance of ProcessedFeatures containing the input features. transition_points ( Tensor ) \u2013 Transition points tensor of shape (batch_size, n_transition_points, 2). Returns: Tensor \u2013 The predicted GAM values. Shape: (batch_size, num_properties) FullModel Bases: Module forward(processed_features, T) Forward pass of the model. Parameters: processed_features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. T ( Tensor ) \u2013 Time tensor of shape (batch_size, n_max_timesteps). Returns: Tensor \u2013 Output tensor of shape (batch_size, n_output_features) predict_from_cached_properties(T) Predict the trajectory from cached properties. Parameters: T ( Tensor ) \u2013 Time tensor of shape (batch_size, n_max_timesteps). Returns: Tensor \u2013 Output tensor of shape (batch_size, n_output_features). predict_properties(processed_features) Predict the properties based on the processed features. Parameters: processed_features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. Returns: Properties \u2013 Predicted properties of the trajectories. ProcessedFeatures __init__(B, B_cat, categorical_features_indices, cat_n_unique_dict, X0=None, x0_index=None) Processed features for the model. Args: B: input tensor of shape (batch_size, n_cont_features, n_basis_functions) B_cat: input tensor of shape (batch_size, sum(cat_n_unique_dict)) categorical_features_indices: list of indices for categorical features cat_n_unique_dict: dictionary with the number of unique values for each categorical feature X0: initial condition tensor of shape (batch_size,1) or None x0_index: index of the initial condition in the feature vector, or a float value to set the initial condition directly PropertyModule Bases: Module predict(processed_features) Predict the properties based on the processed features. Parameters: processed_features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. Returns: Properties \u2013 Predicted properties of the trajectories TransitionPointModule Bases: Module predict(features) Predict the transition points based on the processed features. Parameters: features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. Returns: Tensor \u2013 Predicted transition points of shape (batch_size, n_transition_points, 2). torch_utils calculate_cat_shape_functions(processed_features, cat_weights, positive=True) Args: processed_features: an instance of ProcessedFeatures cat_weights: a dictionary of tensors, each of shape (cat_n_unique_dict, n_properties) positive: boolean, whether the output should be positive or not Returns: output tensor of shape (batch_size, n_properties, n_cat_features) calculate_gams(processed_features, weights, cat_weights, bias, positive=True, sum=False) Calculate the GAMS of the model Args: B: a pair of input tensors of shape (batch_size, n_cont_features, n_basis_functions) and (batch_size, sum(cat_n_unique_dict)) weights: input tensor of shape (n_basis_functions, n_cont_features, n_properties) cat_weights: a dictionary of tensors, each of shape (cat_n_unique_dict, n_properties) bias: input tensor of shape (n_properties) Returns: output tensor of shape (batch_size, n_properties, n_features + 1) if sum is False else (batch_size, n_properties) calculate_shape_functions_for_single_feature(b, feature_index, cont_weights, cat_weights, positive=True) Args: b: input tensor of shape (batch_size, n_basis_functions) or (batch_size, cat_n_unique) if categorical feature_index: integer, index of the feature from [n_features] cont_weights: input tensor of shape (n_basis_functions, n_cont_features, n_properties) or (cat_n_unique, n_properties) if categorical Returns: output tensor of shape (batch_size, n_properties) divide_B_cat_into_blocks(processed_features) Args: processed_features: an instance of ProcessedFeatures Returns: dictionary of tensors, each of shape (batch_size, cat_n_unique_dict) training PropertyModuleTrainer Bases: LightningModule prediction_loss(Y_pred, Y, mask) Calculate the prediction loss. Args: Y_pred: predicted values Y: true values mask: mask to apply to the loss Returns: prediction loss utils filter_by_mask(array, mask) Filter the array by the mask Parameters: array: np.ndarray or list The array to be filtered. mask: np.ndarray or list The mask to filter the array by. It should be a boolean array or list of the same length as the array. from_feature_index_to_cont_feature_index(feature_index, categorical_features_indices) Convert a feature index to a continuous feature index Args: feature_index: integer, index of the feature Returns: output integer get_first_derivative_range(composition, motif_index, point1, point2, which_point) Calculate the first derivative range for a given composition and motif index. Parameters: composition ( Composition ) \u2013 The composition of the model. motif_index ( int ) \u2013 The index of the motif in the composition. point1 ( NpArrayOrTensor ) \u2013 Should be of shape (batch_size, 2) representing the first point. point2 ( NpArrayOrTensor ) \u2013 Should be of shape (batch_size, 2) representing the second point. which_point ( str ) \u2013 Either 'left' or 'right', indicating which side of the motif we are interested in. Returns: Tuple [ NpArrayOrTensor , NpArrayOrTensor ] \u2013 Each shape should be (batch_size,). get_tensors(device, *args) Convert numpy arrays to torch tensors Args: args: numpy arrays Returns: tuple of torch tensors get_train_val_indices(n_samples, train_size=0.8, seed=0) Get the indices for the training and validation sets Parameters: n_samples ( int ) \u2013 The total number of samples. train_size ( float , default: 0.8 ) \u2013 The proportion of the dataset to include in the train split (default is 0.8). seed ( int , default: 0 ) \u2013 Random seed for reproducibility (default is 0). Returns: Tuple [ ndarray , ndarray ] \u2013 Two arrays containing the indices for the training and validation sets. linalg_solve_multiple_numpy(A, b) Solve the linear equation Ax = b for multiple right-hand sides. Parameters: A ( ndarray ) \u2013 Coefficient matrix of shape (m, n, n). b ( ndarray ) \u2013 Right-hand side matrix of shape (m, n). Returns: ndarray \u2013 Solution matrix of shape (m, n). pad_and_mask(arrays) Pads a list of 1D numpy arrays or 1D PyTorch tensors to a 2D array/tensor. Parameters: arrays ( Sequence [ ndarray ] or Sequence [ Tensor ] ) \u2013 A sequence of 1D numpy arrays or 1D PyTorch tensors to be padded. Returns: NpArrayOrTensor \u2013 Padded 2D array or tensor. NpArrayOrTensor \u2013 Mask indicating real entries (1) and padded entries (0). Raises: ValueError \u2013 If the input list is empty. softmax_numpy(x, temperature=1.0) Compute the softmax of vector x with a temperature parameter. Parameters: x (numpy.ndarray): Input data. temperature (float): Temperature parameter for scaling. Returns: numpy.ndarray: Softmax probabilities. transform_first_derivative(boundary, composition, raw_first_derivative, transition_points) Transform the first derivative at the start to the proper range. Only used if first derivative at start is predicted from weights. Parameters: boundary ( str ) \u2013 Either 'start' or 'end', indicating the boundary of the composition. composition ( Composition ) \u2013 The composition of the model. raw_first_derivative ( NpArrayOrTensor ) \u2013 The raw first derivative. Shape should be (batch_size,) transition_points ( NpArrayOrTensor ) \u2013 The transition points of the model. Shape should be (batch_size, n_transition_points, 2). Returns: NpArrayOrTensor \u2013 The transformed first derivative at the start. Shape should be (batch_size,). transform_properties(composition, raw_properties, last_value, first_derivative_at_end) Transform the raw properties to the proper range. Parameters: composition ( Composition ) \u2013 The composition of the model. raw_properties ( NpArrayOrTensor ) \u2013 The raw properties to transform. Shape should be (batch_size, n_properties). last_value ( NpArrayOrTensor ) \u2013 The last value of the trajectory. Shape should be (batch_size,). first_derivative_at_end ( NpArrayOrTensor ) \u2013 The first derivative at the end of the transition. Shape should be (batch_size,). Returns: NpArrayOrTensor \u2013 The transformed properties.","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#episode.basis","text":"","title":"basis"},{"location":"api/#episode.basis.OneHotBasisFunctions","text":"","title":"OneHotBasisFunctions"},{"location":"api/#episode.basis.OneHotBasisFunctions.compute","text":"Compute the one-hot encoded basis functions for the given input and ranges. Parameters: V: a numpy array of shape (n_samples, n_features) V_ranges: a list of tuples or sets representing ranges of the features Returns: B: a numpy array of shape (n_samples, sum(n_unique_values)) n_unique_values_dict: a dictionary mapping feature indices to the number of unique values in each feature","title":"compute"},{"location":"api/#episode.basis.OneHotBasisFunctions.compute_single","text":"Args: V: a numpy array of shape (n_samples, n_features) V_ranges: a list of tuples or sets representing ranges of the features feature_index: index of the feature to compute the one-hot encoding for Returns: B: a numpy array of shape (n_samples, n_unique_values)","title":"compute_single"},{"location":"api/#episode.composition_map","text":"","title":"composition_map"},{"location":"api/#episode.composition_map.CompositionMapBase","text":"Bases: ABC","title":"CompositionMapBase"},{"location":"api/#episode.composition_map.CompositionMapBase.fit","text":"Fit the composition map model. Parameters: V ( FeatureDataset ) \u2013 The feature dataset containing the static features. T ( NpArrayOrList ) \u2013 The target values. Shape should be a list of np.ndarray or a single np.ndarray of shape (n_samples,n_timesteps). Y ( NpArrayOrList ) \u2013 The additional input features. Shape should be a list of np.ndarray or a single np.ndarray of shape (n_samples,n_timesteps). composition_scores ( ndarray , default: None ) \u2013 The composition scores. Shape should be (n_samples, n_compositions), by default None Returns: None \u2013","title":"fit"},{"location":"api/#episode.composition_map.CompositionMapBase.get_specific_feature_ranges","text":"Get the range of the features for a specific composition Parameters: X_ranges ( list [ tuple [ float , float ] | set [ int ]] ) \u2013 The ranges of the features for all compositions. composition_index ( int ) \u2013 The index of the composition to get the feature ranges for. Returns: list [ tuple [ float , float ] | set [ int ]] \u2013 The ranges of the features for the specified composition.","title":"get_specific_feature_ranges"},{"location":"api/#episode.composition_map.CompositionMapBase.predict","text":"Predict the composition for the given input. Parameters: V ( FeatureDataset ) \u2013 The feature dataset containing the static features. include_indices ( bool ) \u2013 Whether to include the indices of the compositions, by default False Returns: Sequence [ Composition ] | Tuple [ Sequence [ Composition ], ndarray ] \u2013 If include_indices is False, returns a sequence of Composition objects. If include_indices is True, returns a tuple containing the sequence of Composition objects and the indices of the compositions.","title":"predict"},{"location":"api/#episode.composition_map.DecisionTreeCompositionMap","text":"Bases: CompositionMapBase","title":"DecisionTreeCompositionMap"},{"location":"api/#episode.composition_map.DecisionTreeCompositionMap.__init__","text":"Args: composition_library: a sequence of Composition objects dt_config: a dictionary with the configuration for the decision tree classifier categorical_features_indices: a sequence of integers representing the indices of the categorical features x0_index: an integer or float representing the index of the initial condition, or None if not included verbose: a boolean indicating whether to print the decision tree structure","title":"__init__"},{"location":"api/#episode.composition_map.DecisionTreeCompositionMap.get_specific_feature_ranges","text":"Get the range of the features for a specific composition. Parameters: X_ranges ( list [ tuple [ float , float ] | set [ int ]] ) \u2013 The ranges of the features for all compositions. composition_index ( int ) \u2013 The index of the composition to get the feature ranges for. Returns: list [ tuple [ float , float ] | set [ int ]] \u2013 The ranges of the features for the specified composition.","title":"get_specific_feature_ranges"},{"location":"api/#episode.composition_map.DecisionTreeCompositionMap.predict_composition_indices","text":"Predict the composition indices for the given input. Parameters: V ( FeatureDataset ) \u2013 The feature dataset containing the static features. Returns: ndarray \u2013 The predicted composition indices. Shape will be (n_samples,).","title":"predict_composition_indices"},{"location":"api/#episode.config","text":"","title":"config"},{"location":"api/#episode.config.ConfigBase","text":"Base class for configuration management. Provides methods to update configurations and validate keys.","title":"ConfigBase"},{"location":"api/#episode.config.ConfigBase.copy","text":"Create a copy of the configuration instance.","title":"copy"},{"location":"api/#episode.config.ConfigBase.from_dict","text":"Create a ConfigBase instance from a dictionary.","title":"from_dict"},{"location":"api/#episode.config.ConfigBase.to_dict","text":"Convert the configuration to a dictionary.","title":"to_dict"},{"location":"api/#episode.config.DecisionTreeConfig","text":"","title":"DecisionTreeConfig"},{"location":"api/#episode.config.DecisionTreeConfig.__init__","text":"Initialize the configuration for the decision tree. Parameters: max_depth ( int , default: 3 ) \u2013 Maximum depth of the tree, by default 3 min_relative_gain_to_split ( float , default: 0.01 ) \u2013 Minimum relative gain to split, by default 1e-2 min_samples_leaf ( int , default: 10 ) \u2013 Minimum samples per leaf, by default 10 relative_motif_cost ( float , default: 0.01 ) \u2013 Relative cost of motif, by default 1e-2 tune_depth ( bool , default: False ) \u2013 Whether to tune the depth of the tree, by default False","title":"__init__"},{"location":"api/#episode.config.PropertyMapConfig","text":"Bases: ConfigBase Configuration class for PropertyMapTorch. Inherits from ConfigBase to manage configuration settings.","title":"PropertyMapConfig"},{"location":"api/#episode.config.PropertyMapConfig.__init__","text":"Initialize the configuration for PropertyMapTorch.","title":"__init__"},{"location":"api/#episode.config.TorchTrainerConfig","text":"Configuration class for the PyTorch trainer. Inherits from ConfigBase to manage configuration settings.","title":"TorchTrainerConfig"},{"location":"api/#episode.config.TorchTrainerConfig.__init__","text":"Initialize the configuration for the PyTorch trainer.","title":"__init__"},{"location":"api/#episode.config.TorchTrainerConfig.copy","text":"Create a copy of the configuration instance.","title":"copy"},{"location":"api/#episode.cubic","text":"","title":"cubic"},{"location":"api/#episode.cubic.create_row","text":"Create a row of polynomial features for a given coordinate. Parameters: coordinate ( ndarray | Tensor ) \u2013 Coordinate for which to create the polynomial features. Should be of shape (batch_size, 2). order ( int ) \u2013 Order of the polynomial features. 0 for the function, 1 for the first derivative, and 2 for the second derivative. Returns: ndarray | Tensor \u2013 Row of polynomial features for the given coordinate and order. Shape: (batch_size, 4) Raises: ValueError \u2013 If the order is not 0, 1, or 2.","title":"create_row"},{"location":"api/#episode.cubic.evaluate_cubic","text":"Evaluate a cubic polynomial at x (or its derivatives). Parameters: coefficients : np.ndarray Coefficients of the cubic polynomial. Should be of shape (batch_size,4) The coefficients are ordered as [a,b,c,d] where the polynomial is a x^3 + b x^2 + c*x + d x : np.ndarray Input data. Should be (batch_size,n_time_points) derivative_order : int Order of derivative to evaluate. Returns: np.ndarray Value of the cubic polynomial at x. Should be (batch_size,n_time_points)","title":"evaluate_cubic"},{"location":"api/#episode.cubic.first_derivative_at_end_from_cubic","text":"summary Parameters: coefficients ( ndarray | Tensor ) \u2013 Coefficients of the cubics of shape (batch_size, n_bounded_motifs, 4) t_end ( ndarray | Tensor ) \u2013 Time points of the final bounded transition points of shape (batch_size,) Returns: ndarray | Tensor \u2013 First derivatives at the end of the cubics of shape (batch_size,)","title":"first_derivative_at_end_from_cubic"},{"location":"api/#episode.cubic.second_derivative_at_end_from_cubic","text":"Calculate the second derivative at the end of the cubic. Parameters: coefficients ( ndarray | Tensor ) \u2013 Coefficients of the cubics of shape (batch_size, n_bounded_motifs, 4) t_end ( ndarray | Tensor ) \u2013 Time points of the final bounded transition points of shape (batch_size,) Returns: ndarray | Tensor \u2013 Second derivatives at the end of the cubics of shape (batch_size,)","title":"second_derivative_at_end_from_cubic"},{"location":"api/#episode.decision_tree","text":"","title":"decision_tree"},{"location":"api/#episode.decision_tree.DecisionTreeClassifier","text":"CART Decision Tree for classification with support for: - Numeric features - Categorical features - One-hot encoded labels","title":"DecisionTreeClassifier"},{"location":"api/#episode.decision_tree.DecisionTreeClassifier.__init__","text":"Parameters: max_depth ( int , default: 5 ) \u2013 The maximum depth of the tree. min_samples_split ( int , default: 2 ) \u2013 The minimum number of samples required to split an internal node. categorical_features ( list of int , default: None ) \u2013 List of feature indices that are categorical. By default, None means all features are treated as numeric.","title":"__init__"},{"location":"api/#episode.decision_tree.DecisionTreeClassifier.continue_fit","text":"Incrementally fit the tree with new data (X_new, Y_new).","title":"continue_fit"},{"location":"api/#episode.decision_tree.DecisionTreeClassifier.fit","text":"Fit the decision tree to the data. Parameters: X ( np.ndarray of shape (n_samples, n_features) ) \u2013 Y ( np.ndarray of shape (n_samples, n_classes) ) \u2013","title":"fit"},{"location":"api/#episode.decision_tree.DecisionTreeClassifier.get_predictions_at_leaves","text":"Get a set of all possible predictions","title":"get_predictions_at_leaves"},{"location":"api/#episode.decision_tree.DecisionTreeClassifier.get_updated_feature_ranges","text":"Get the updated feature ranges for the new tree.","title":"get_updated_feature_ranges"},{"location":"api/#episode.decision_tree.DecisionTreeClassifier.predict","text":"Predict class labels for each sample in X. Parameters: X ( np.ndarray of shape (n_samples, n_features) ) \u2013 Returns: np.ndarray of shape (n_samples,) \u2013 The predicted class labels (as integers).","title":"predict"},{"location":"api/#episode.decision_tree.DecisionTreeClassifier.predict_proba","text":"Predict class probabilities for each sample in X. Parameters: X ( np.ndarray of shape (n_samples, n_features) ) \u2013 Returns: np.ndarray of shape (n_samples, n_classes) \u2013","title":"predict_proba"},{"location":"api/#episode.decision_tree.DecisionTreeClassifier.print_tree","text":"Recursively print the structure of the decision tree. Parameters: node ( TreeNode , default: None ) \u2013 The current node in the tree. If None, starts from the root. depth ( int , default: 0 ) \u2013 Current depth of the tree, used for indentation.","title":"print_tree"},{"location":"api/#episode.decision_tree.TreeNode","text":"A simple class representing a node in the decision tree.","title":"TreeNode"},{"location":"api/#episode.decision_tree.TreeNode.__init__","text":"Parameters: feature_index ( int , default: None ) \u2013 The index of the feature used for splitting. split_value ( float or any ( threshold or category ) , default: None ) \u2013 If is_categorical=False, this is the numeric threshold. If is_categorical=True, this is the specific category. left ( TreeNode , default: None ) \u2013 Left child node. right ( TreeNode , default: None ) \u2013 Right child node. value ( ndarray , default: None ) \u2013 The class distribution (probabilities) of the leaf node. is_categorical ( bool , default: False ) \u2013 Whether the feature at feature_index is categorical.","title":"__init__"},{"location":"api/#episode.gam","text":"","title":"gam"},{"location":"api/#episode.gam.GAM","text":"","title":"GAM"},{"location":"api/#episode.gam.GAM.__init__","text":"Args: shape_functions: a list of ShapeFunction, each shape function is a function that takes a numpy array bias: a scalar","title":"__init__"},{"location":"api/#episode.gam.GAM.predict","text":"Predict the value of the GAM Args: X: a numpy array of shape (batch_size, n_features) Returns: a numpy array of shape (batch_size,)","title":"predict"},{"location":"api/#episode.gam.GAM.prune","text":"Prune the shape functions whose range is smaller than the threshold","title":"prune"},{"location":"api/#episode.gam.ShapeFunction","text":"","title":"ShapeFunction"},{"location":"api/#episode.gam.ShapeFunction.__call__","text":"Args: x: a numpy array of shape (batch_size,)","title":"__call__"},{"location":"api/#episode.gam.ShapeFunction.get_expected_value","text":"Calculate the expected value of the shape function Returns: a scalar","title":"get_expected_value"},{"location":"api/#episode.gam.ShapeFunction.is_constant","text":"Check if the shape function is constant Returns: a boolean","title":"is_constant"},{"location":"api/#episode.gam.ShapeFunction.maximum_value","text":"Calculate the maximum value of the shape function Returns: a scalar","title":"maximum_value"},{"location":"api/#episode.gam.ShapeFunction.minimum_value","text":"Calculate the minimum value of the shape function Returns: a scalar","title":"minimum_value"},{"location":"api/#episode.gam.ShapeFunction.range","text":"Calculate the range of the shape function Returns: a tuple (min, max)","title":"range"},{"location":"api/#episode.gam.ShapeFunction.visualize","text":"Creates a visualization of the shape function. It consists of two axes objects: one for the shape function and one for the histogram of the data. Returns: a figure object","title":"visualize"},{"location":"api/#episode.optimize_properties","text":"","title":"optimize_properties"},{"location":"api/#episode.optimize_properties.ScipyOptimizationAlgorithm","text":"Bases: OptimizationAlgorithm Optimization algorithm using SciPy's minimize function. This class allows for different optimization methods to be specified.","title":"ScipyOptimizationAlgorithm"},{"location":"api/#episode.optimize_properties.ScipyOptimizationAlgorithm.__init__","text":"Parameters: method ( str , default: 'L-BFGS-B' ) \u2013 The optimization method to use. Defaults to 'L-BFGS-B'.","title":"__init__"},{"location":"api/#episode.optimize_properties.calculate_score","text":"Calculate the score for the given composition and data. Parameters: composition ( Composition ) \u2013 The composition object containing motif information. t_range ( Tuple [ float , float ] ) \u2013 The time range for the evaluation. t ( ndarray ) \u2013 The time points for the evaluation. Shape (n_time_points,). x ( ndarray ) \u2013 The state variables for the evaluation. Shape (n_time_points). x0 ( Union [ float , None] ) \u2013 The initial state variable, if applicable. optimization_alg ( OptimizationAlgorithm ) \u2013 The optimization algorithm to use. loss_fn ( Callable ) \u2013 The loss function to minimize. Signature should be loss_fn(x_pred, x_true) -> float or loss_fn(x_pred, x_true) -> np.ndarray . train_on_all ( bool , default: False ) \u2013 Whether to train on all available data, by default False. evaluate_on_all ( bool , default: True ) \u2013 Whether to evaluate on all available data, by default True. train_size ( float , default: 0.8 ) \u2013 The proportion of data to use for training, by default 0.8. seed ( int , default: 0 ) \u2013 The random seed for reproducibility, by default 0. Returns: Tuple [ float , Properties ] \u2013 The loss value and the properties object containing the optimized parameters.","title":"calculate_score"},{"location":"api/#episode.optimize_properties.compute_t_last_finite_transition_point","text":"Returns the last finite transition point in time based on the composition and arguments. If the composition is bounded, it returns the end of the time range. Parameters: composition ( Composition ) \u2013 The composition object containing motif information. t_range ( Tuple [ float , float ] ) \u2013 The time range for the evaluation. arguments ( dict ) \u2013 A dictionary containing the arguments, including 't_last_finite_transition_point'. t_max ( float ) \u2013 The maximum time point in the data. Returns: float \u2013 The last finite transition point in time.","title":"compute_t_last_finite_transition_point"},{"location":"api/#episode.optimize_properties.from_parameters_to_raw_properties","text":"Converts a flat array of parameters into a dictionary of arguments based on the provided mapping. Parameters: parameters ( ndarray ) \u2013 A flat array of parameters. dictionary ( dict ) \u2013 A mapping from argument names to their corresponding indices in the parameters array. key is argument name such as \"horizontal_values\", \"vertical_values\", etc. value is a tuple indicating the start and end indices in the parameters array, or None if not applicable. Returns: dict \u2013 A dictionary mapping argument names to their corresponding values.","title":"from_parameters_to_raw_properties"},{"location":"api/#episode.optimize_properties.get_first_derivative_range","text":"Get the range of the first derivative for a given motif and transition points. Parameters: composition ( Composition ) \u2013 The composition object containing motif information. motif_index ( int ) \u2013 Index of the motif in the composition. point1 ( ndarray ) \u2013 numpy array of shape (2,) representing the first point (time, value). point2 ( ndarray ) \u2013 numpy array of shape (2,) representing the second point (time, value). which_point ( str ) \u2013 'left' or 'right' indicating which point to consider for the derivative. Returns: Tuple [ float , float ] \u2013 The range of the first derivative at the specified point.","title":"get_first_derivative_range"},{"location":"api/#episode.optimize_properties.transition_points_from_raw_properties","text":"Converts raw properties into transition points. Parameters: horizontal_values ( ndarray ) \u2013 The horizontal shifts betweet transition points. 1D array vertical_values ( ndarray ) \u2013 The vertical shifts between transition points. 1D array t_last_finite_transition_point ( float ) \u2013 The last finite transition point in time. x0 ( float ) \u2013 The initial state variable. Returns: ndarray \u2013 The calculated transition points of shape (num_transition_points, 2).","title":"transition_points_from_raw_properties"},{"location":"api/#episode.property_map","text":"","title":"property_map"},{"location":"api/#episode.property_map.CubicDerivativePredictor","text":"Bases: PropertyFunction","title":"CubicDerivativePredictor"},{"location":"api/#episode.property_map.CubicDerivativePredictor.predict","text":"Predict the value of the derivative based on the cubic. Parameters: V ( ndarray ) \u2013 A numpy array of shape (batch_size, n_features) containing the input features. Returns: ndarray \u2013 A numpy array containing the predicted values for the specified order. Shape is (batch_size,).","title":"predict"},{"location":"api/#episode.property_map.GAMBasedDerivativePredictor","text":"Bases: PropertyFunction","title":"GAMBasedDerivativePredictor"},{"location":"api/#episode.property_map.GAMBasedDerivativePredictor.__init__","text":"Initialize the DerivativePredictor with a dictionary of predictors. Parameters: gam ( GAM ) \u2013 The GAM instance used for predictions. boundary ( str ) \u2013 The boundary to predict ('start' or 'end'). order ( int ) \u2013 The order of the derivative to predict (1 or 2).","title":"__init__"},{"location":"api/#episode.property_map.GAMBasedDerivativePredictor.predict","text":"Predict the value of the derivative. Parameters: V ( ndarray ) \u2013 A numpy array of shape (batch_size, n_features) containing the input features. Returns: ndarray \u2013 A numpy array containing the predicted values for the specified boundary and order. Shape is (batch_size,).","title":"predict"},{"location":"api/#episode.property_map.GAMBasedInfiniteMotifPredictor","text":"Bases: PropertyFunction","title":"GAMBasedInfiniteMotifPredictor"},{"location":"api/#episode.property_map.GAMBasedInfiniteMotifPredictor.__init__","text":"Initialize the GAMBasedInfiniteMotifPredictor. Parameters: composition ( Composition ) \u2013","title":"__init__"},{"location":"api/#episode.property_map.GAMBasedInfiniteMotifPredictor.predict","text":"Predict the value of an infinite motif property. Parameters: V ( ndarray ) \u2013 A numpy array of shape (batch_size, n_features) containing the input features. Returns: ndarray \u2013 A numpy array containing the predicted values for the specified infinite motif property. Shape is (batch_size,).","title":"predict"},{"location":"api/#episode.property_map.NDPropertyMap","text":"Bases: NDPropertyMapBase","title":"NDPropertyMap"},{"location":"api/#episode.property_map.NDPropertyMap.init_property_map","text":"Initialize the 1D property map.","title":"init_property_map"},{"location":"api/#episode.property_map.NDPropertyMapBase","text":"Bases: ABC","title":"NDPropertyMapBase"},{"location":"api/#episode.property_map.NDPropertyMapBase.init_property_map","text":"Initialize the 1D property map.","title":"init_property_map"},{"location":"api/#episode.property_map.PropertyFunction","text":"Bases: ABC","title":"PropertyFunction"},{"location":"api/#episode.property_map.PropertyFunction.predict","text":"Predict the output for a given input. Parameters: X ( ndarray ) \u2013 Input data of shape (n_samples, n_features). Returns: ndarray \u2013 Predicted output of shape (n_samples,).","title":"predict"},{"location":"api/#episode.property_map.PropertyMap","text":"Bases: PropertyMapBase","title":"PropertyMap"},{"location":"api/#episode.property_map.PropertyMapBase","text":"Bases: ABC","title":"PropertyMapBase"},{"location":"api/#episode.property_map.PropertyMapBase.fit","text":"Fit the semantic predictor to the data Parameters: V: FeatureDataset The input feature dataset. T: NpArrayOrList The target values. Y: NpArrayOrList The additional target values.","title":"fit"},{"location":"api/#episode.property_map.PropertyMapBase.predict","text":"Predict the properties for a given composition and input features. Parameters: composition ( Composition ) \u2013 The composition for which to predict properties. V ( FeatureDataset ) \u2013 A dataset containing the input features. Returns: Properties \u2013 An instance of Properties containing the predicted properties.","title":"predict"},{"location":"api/#episode.property_map.SinglePropertyMap","text":"","title":"SinglePropertyMap"},{"location":"api/#episode.property_map.SinglePropertyMap.__init__","text":"Args: composition: a tuple of strings representing the composition transition_point_predictor: a dictionary with keys (transition_point_index: int,coordinate: {'x','t'}) and values of type GAM derivative_predictor: a dictionary with keys (boundary: {'start','end'},order: {1,2}) and values of type GAM infinite_motif_predictor: a list of GAM","title":"__init__"},{"location":"api/#episode.property_map.SinglePropertyMap.predict","text":"Predict the properties for a given input. Parameters: V ( ndarray ) \u2013 A numpy array of shape (batch_size, n_features) containing the input features. Returns: Properties \u2013 An instance of Properties containing the predicted properties.","title":"predict"},{"location":"api/#episode.property_map.TransitionPointPredictor","text":"Bases: PropertyFunction","title":"TransitionPointPredictor"},{"location":"api/#episode.property_map.TransitionPointPredictor.__init__","text":"Parameters: transition_point_module ( TransitionPointModule ) \u2013 The module that predicts the transition points. transition_point_index ( int ) \u2013 The index of the transition point to predict. coordinate ( str ) \u2013 The coordinate to predict ('x' or 't').","title":"__init__"},{"location":"api/#episode.property_map.TransitionPointPredictor.predict","text":"summary Parameters: V ( ndarray ) \u2013 A numpy array of shape (batch_size, n_features) containing the input features. Returns: ndarray \u2013 A numpy array containing the predicted values for the specified transition point and coordinate. Shape is (batch_size,).","title":"predict"},{"location":"api/#episode.semantic_predictor","text":"","title":"semantic_predictor"},{"location":"api/#episode.semantic_predictor.SemanticPredictor","text":"","title":"SemanticPredictor"},{"location":"api/#episode.semantic_predictor.SemanticPredictor.__init__","text":"Args: compostion_map: a CompositionMap object property_maps: a dictionary with keys (composition: tuple of strings) and values of type SinglePropertyMap t_range: a tuple of floats representing the range of the time variable","title":"__init__"},{"location":"api/#episode.semantic_predictor.SemanticPredictor.fit","text":"Fit the semantic predictor to the data Parameters: V: FeatureDataset The input feature dataset. T: NpArrayOrList The target values. Y: NpArrayOrList The additional target values.","title":"fit"},{"location":"api/#episode.semantic_predictor.SemanticPredictor.predict","text":"Predict the semantic representation Args: V: a numpy array of shape (batch_size, n_features) Returns: a list of SemanticRepresentation objects","title":"predict"},{"location":"api/#episode.semantic_representation","text":"","title":"semantic_representation"},{"location":"api/#episode.semantic_representation.Composition","text":"","title":"Composition"},{"location":"api/#episode.semantic_representation.Composition.create_composition","text":"Create a Composition object from a sequence of motifs. Parameters: motifs ( Tuple [ str , ...] | Sequence [ str ] ) \u2013 A sequence of motif strings. Returns: Composition \u2013 A Composition object representing the motifs.","title":"create_composition"},{"location":"api/#episode.semantic_representation.Composition.create_composition_library","text":"Create a library of Composition objects from a list of motifs. Parameters: list_of_motifs ( Sequence [ Tuple [ str , ...]] | Sequence [ Sequence [ str ]] ) \u2013 A sequence of sequences of motif strings. Returns: Sequence [ Composition ] \u2013 A list of Composition objects representing the motifs.","title":"create_composition_library"},{"location":"api/#episode.semantic_representation.Properties","text":"","title":"Properties"},{"location":"api/#episode.semantic_representation.Properties.__init__","text":"Initialize the Properties class. Parameters: engine ( str ) \u2013 The computational engine to use ('pytorch' or 'numpy'). composition ( Composition ) \u2013 Composition object containing motif information. transition_points ( Union [ ndarray , Tensor ] ) \u2013 Array or tensor of transition points of shape (n_samples, n_transition_points,2). first_derivative_start ( Union [ ndarray , Tensor ] ) \u2013 Array or tensor of first derivative start points of shape (n_samples, 1). first_derivative_end ( Union [ ndarray , Tensor ] ) \u2013 Array or tensor of first derivative end points of shape (n_samples, 1). second_derivative_end ( Union [ ndarray , Tensor ] ) \u2013 Array or tensor of second derivative end points of shape (n_samples, 1). unbounded_motif_properties ( Union [None, ndarray , Tensor ] , default: None ) \u2013 Properties for unbounded motifs, if applicable. Defaults to None. Raises: ValueError \u2013 If the engine is not 'pytorch' or 'numpy'.","title":"__init__"},{"location":"api/#episode.semantic_representation.SemanticRepresentation","text":"","title":"SemanticRepresentation"},{"location":"api/#episode.semantic_representation.SemanticRepresentation.__init__","text":"Initialize the SemanticRepresentation class. Parameters: compositions ( Sequence [ Composition ] ) \u2013 A sequence of Composition objects. predicted_composition_indices ( ndarray ) \u2013 An array of predicted composition indices. Should be of shape (n_samples,) and contain integers representing indices of compositions. engine ( str , default: 'numpy' ) \u2013 The computational engine to use ('pytorch' or 'numpy'), by default 'numpy'","title":"__init__"},{"location":"api/#episode.semantic_representation.SemanticRepresentation.get_present_compositions","text":"Get a list of compositions that have associated properties. Returns: Sequence [ Composition ] \u2013 A sequence of compositions with properties.","title":"get_present_compositions"},{"location":"api/#episode.semantic_representation.SemanticRepresentation.get_properties_by_composition","text":"Get properties for a specific composition. Parameters: composition ( Composition ) \u2013 The composition for which to retrieve properties. Returns: Properties \u2013 The properties associated with the specified composition.","title":"get_properties_by_composition"},{"location":"api/#episode.torch_model","text":"","title":"torch_model"},{"location":"api/#episode.torch_model.DerivativeModule","text":"Bases: Module","title":"DerivativeModule"},{"location":"api/#episode.torch_model.DerivativeModule.predict","text":"Predict the derivatives based on the processed features and finite coordinates. Parameters: features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. finite_coordinates ( Tensor ) \u2013 Finite coordinates tensor of shape (batch_size, n_coordinates, 2). Returns: tuple \u2013 A tuple containing three tensors: the predicted first derivative at the start, the predicted first derivative at the end, and the predicted second derivative at the end. Each tensor has shape (batch_size,).","title":"predict"},{"location":"api/#episode.torch_model.DerivativeModule.predict_first_derivative_at_end","text":"Predict the first derivative at the end of the transition. Parameters: features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. transition_points ( Tensor ) \u2013 Transition points tensor of shape (batch_size, n_transition_points, 2). Returns: Tensor \u2013 Predicted first derivative at the end of the transition. Shape: (batch_size,) Raises: ValueError \u2013 If the first_derivative_at_end_status is unknown.","title":"predict_first_derivative_at_end"},{"location":"api/#episode.torch_model.DerivativeModule.predict_first_derivative_at_start","text":"Predict the first derivative at the start of the transition. Parameters: features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. transition_points ( Tensor ) \u2013 Transition points tensor of shape (batch_size, n_transition_points, 2). Returns: Tensor \u2013 Predicted first derivative at the start of the transition. Shape: (batch_size,) Raises: ValueError \u2013 If the first_derivative_at_start_status is unknown.","title":"predict_first_derivative_at_start"},{"location":"api/#episode.torch_model.DerivativeModule.predict_second_derivative_at_end","text":"Predict the second derivative at the end of the transition. Parameters: features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. Returns: Tensor \u2013 Predicted second derivative at the end of the transition. Shape: (batch_size,) Raises: ValueError \u2013 If the second_derivative_at_end_status is unknown.","title":"predict_second_derivative_at_end"},{"location":"api/#episode.torch_model.FinalMotifPropertyModule","text":"Bases: Module","title":"FinalMotifPropertyModule"},{"location":"api/#episode.torch_model.FinalMotifPropertyModule.predict","text":"Predict the generalized additive model (GAM) for the given processed features. Parameters: processed_features ( ProcessedFeatures ) \u2013 An instance of ProcessedFeatures containing the input features. transition_points ( Tensor ) \u2013 Transition points tensor of shape (batch_size, n_transition_points, 2). Returns: Tensor \u2013 The predicted GAM values. Shape: (batch_size, num_properties)","title":"predict"},{"location":"api/#episode.torch_model.FullModel","text":"Bases: Module","title":"FullModel"},{"location":"api/#episode.torch_model.FullModel.forward","text":"Forward pass of the model. Parameters: processed_features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. T ( Tensor ) \u2013 Time tensor of shape (batch_size, n_max_timesteps). Returns: Tensor \u2013 Output tensor of shape (batch_size, n_output_features)","title":"forward"},{"location":"api/#episode.torch_model.FullModel.predict_from_cached_properties","text":"Predict the trajectory from cached properties. Parameters: T ( Tensor ) \u2013 Time tensor of shape (batch_size, n_max_timesteps). Returns: Tensor \u2013 Output tensor of shape (batch_size, n_output_features).","title":"predict_from_cached_properties"},{"location":"api/#episode.torch_model.FullModel.predict_properties","text":"Predict the properties based on the processed features. Parameters: processed_features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. Returns: Properties \u2013 Predicted properties of the trajectories.","title":"predict_properties"},{"location":"api/#episode.torch_model.ProcessedFeatures","text":"","title":"ProcessedFeatures"},{"location":"api/#episode.torch_model.ProcessedFeatures.__init__","text":"Processed features for the model. Args: B: input tensor of shape (batch_size, n_cont_features, n_basis_functions) B_cat: input tensor of shape (batch_size, sum(cat_n_unique_dict)) categorical_features_indices: list of indices for categorical features cat_n_unique_dict: dictionary with the number of unique values for each categorical feature X0: initial condition tensor of shape (batch_size,1) or None x0_index: index of the initial condition in the feature vector, or a float value to set the initial condition directly","title":"__init__"},{"location":"api/#episode.torch_model.PropertyModule","text":"Bases: Module","title":"PropertyModule"},{"location":"api/#episode.torch_model.PropertyModule.predict","text":"Predict the properties based on the processed features. Parameters: processed_features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. Returns: Properties \u2013 Predicted properties of the trajectories","title":"predict"},{"location":"api/#episode.torch_model.TransitionPointModule","text":"Bases: Module","title":"TransitionPointModule"},{"location":"api/#episode.torch_model.TransitionPointModule.predict","text":"Predict the transition points based on the processed features. Parameters: features ( ProcessedFeatures ) \u2013 Processed features containing B, B_cat, categorical features indices, and categorical unique counts. Returns: Tensor \u2013 Predicted transition points of shape (batch_size, n_transition_points, 2).","title":"predict"},{"location":"api/#episode.torch_utils","text":"","title":"torch_utils"},{"location":"api/#episode.torch_utils.calculate_cat_shape_functions","text":"Args: processed_features: an instance of ProcessedFeatures cat_weights: a dictionary of tensors, each of shape (cat_n_unique_dict, n_properties) positive: boolean, whether the output should be positive or not Returns: output tensor of shape (batch_size, n_properties, n_cat_features)","title":"calculate_cat_shape_functions"},{"location":"api/#episode.torch_utils.calculate_gams","text":"Calculate the GAMS of the model Args: B: a pair of input tensors of shape (batch_size, n_cont_features, n_basis_functions) and (batch_size, sum(cat_n_unique_dict)) weights: input tensor of shape (n_basis_functions, n_cont_features, n_properties) cat_weights: a dictionary of tensors, each of shape (cat_n_unique_dict, n_properties) bias: input tensor of shape (n_properties) Returns: output tensor of shape (batch_size, n_properties, n_features + 1) if sum is False else (batch_size, n_properties)","title":"calculate_gams"},{"location":"api/#episode.torch_utils.calculate_shape_functions_for_single_feature","text":"Args: b: input tensor of shape (batch_size, n_basis_functions) or (batch_size, cat_n_unique) if categorical feature_index: integer, index of the feature from [n_features] cont_weights: input tensor of shape (n_basis_functions, n_cont_features, n_properties) or (cat_n_unique, n_properties) if categorical Returns: output tensor of shape (batch_size, n_properties)","title":"calculate_shape_functions_for_single_feature"},{"location":"api/#episode.torch_utils.divide_B_cat_into_blocks","text":"Args: processed_features: an instance of ProcessedFeatures Returns: dictionary of tensors, each of shape (batch_size, cat_n_unique_dict)","title":"divide_B_cat_into_blocks"},{"location":"api/#episode.training","text":"","title":"training"},{"location":"api/#episode.training.PropertyModuleTrainer","text":"Bases: LightningModule","title":"PropertyModuleTrainer"},{"location":"api/#episode.training.PropertyModuleTrainer.prediction_loss","text":"Calculate the prediction loss. Args: Y_pred: predicted values Y: true values mask: mask to apply to the loss Returns: prediction loss","title":"prediction_loss"},{"location":"api/#episode.utils","text":"","title":"utils"},{"location":"api/#episode.utils.filter_by_mask","text":"Filter the array by the mask Parameters: array: np.ndarray or list The array to be filtered. mask: np.ndarray or list The mask to filter the array by. It should be a boolean array or list of the same length as the array.","title":"filter_by_mask"},{"location":"api/#episode.utils.from_feature_index_to_cont_feature_index","text":"Convert a feature index to a continuous feature index Args: feature_index: integer, index of the feature Returns: output integer","title":"from_feature_index_to_cont_feature_index"},{"location":"api/#episode.utils.get_first_derivative_range","text":"Calculate the first derivative range for a given composition and motif index. Parameters: composition ( Composition ) \u2013 The composition of the model. motif_index ( int ) \u2013 The index of the motif in the composition. point1 ( NpArrayOrTensor ) \u2013 Should be of shape (batch_size, 2) representing the first point. point2 ( NpArrayOrTensor ) \u2013 Should be of shape (batch_size, 2) representing the second point. which_point ( str ) \u2013 Either 'left' or 'right', indicating which side of the motif we are interested in. Returns: Tuple [ NpArrayOrTensor , NpArrayOrTensor ] \u2013 Each shape should be (batch_size,).","title":"get_first_derivative_range"},{"location":"api/#episode.utils.get_tensors","text":"Convert numpy arrays to torch tensors Args: args: numpy arrays Returns: tuple of torch tensors","title":"get_tensors"},{"location":"api/#episode.utils.get_train_val_indices","text":"Get the indices for the training and validation sets Parameters: n_samples ( int ) \u2013 The total number of samples. train_size ( float , default: 0.8 ) \u2013 The proportion of the dataset to include in the train split (default is 0.8). seed ( int , default: 0 ) \u2013 Random seed for reproducibility (default is 0). Returns: Tuple [ ndarray , ndarray ] \u2013 Two arrays containing the indices for the training and validation sets.","title":"get_train_val_indices"},{"location":"api/#episode.utils.linalg_solve_multiple_numpy","text":"Solve the linear equation Ax = b for multiple right-hand sides. Parameters: A ( ndarray ) \u2013 Coefficient matrix of shape (m, n, n). b ( ndarray ) \u2013 Right-hand side matrix of shape (m, n). Returns: ndarray \u2013 Solution matrix of shape (m, n).","title":"linalg_solve_multiple_numpy"},{"location":"api/#episode.utils.pad_and_mask","text":"Pads a list of 1D numpy arrays or 1D PyTorch tensors to a 2D array/tensor. Parameters: arrays ( Sequence [ ndarray ] or Sequence [ Tensor ] ) \u2013 A sequence of 1D numpy arrays or 1D PyTorch tensors to be padded. Returns: NpArrayOrTensor \u2013 Padded 2D array or tensor. NpArrayOrTensor \u2013 Mask indicating real entries (1) and padded entries (0). Raises: ValueError \u2013 If the input list is empty.","title":"pad_and_mask"},{"location":"api/#episode.utils.softmax_numpy","text":"Compute the softmax of vector x with a temperature parameter. Parameters: x (numpy.ndarray): Input data. temperature (float): Temperature parameter for scaling. Returns: numpy.ndarray: Softmax probabilities.","title":"softmax_numpy"},{"location":"api/#episode.utils.transform_first_derivative","text":"Transform the first derivative at the start to the proper range. Only used if first derivative at start is predicted from weights. Parameters: boundary ( str ) \u2013 Either 'start' or 'end', indicating the boundary of the composition. composition ( Composition ) \u2013 The composition of the model. raw_first_derivative ( NpArrayOrTensor ) \u2013 The raw first derivative. Shape should be (batch_size,) transition_points ( NpArrayOrTensor ) \u2013 The transition points of the model. Shape should be (batch_size, n_transition_points, 2). Returns: NpArrayOrTensor \u2013 The transformed first derivative at the start. Shape should be (batch_size,).","title":"transform_first_derivative"},{"location":"api/#episode.utils.transform_properties","text":"Transform the raw properties to the proper range. Parameters: composition ( Composition ) \u2013 The composition of the model. raw_properties ( NpArrayOrTensor ) \u2013 The raw properties to transform. Shape should be (batch_size, n_properties). last_value ( NpArrayOrTensor ) \u2013 The last value of the trajectory. Shape should be (batch_size,). first_derivative_at_end ( NpArrayOrTensor ) \u2013 The first derivative at the end of the transition. Shape should be (batch_size,). Returns: NpArrayOrTensor \u2013 The transformed properties.","title":"transform_properties"}]}